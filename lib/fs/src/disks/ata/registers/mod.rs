/*
  ____                 __               __   _ __
 / __ \__ _____ ____  / /___ ____ _    / /  (_) /
/ /_/ / // / _ `/ _ \/ __/ // /  ' \  / /__/ / _ \
\___\_\_,_/\_,_/_//_/\__/\_,_/_/_/_/ /____/_/_.__/
  Part of the Quantum OS Project

Copyright 2023 Gavin Kellam

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

use core::slice::Iter;
use quantum_lib::x86_64::io::port::IOPort;

pub mod command;
pub mod data;
pub mod drive_head;
pub mod error;
pub mod feature;
pub mod sector;
pub mod status;

pub const PRIMARY_BUS_IO_BASE: IOPortOffset = 0x1F0;
pub const SECONDARY_BUS_IO_BASE: IOPortOffset = 0x170;

pub const PRIMARY_BUS_CONTROL_BASE: IOPortOffset = 0x3F6;
pub const SECONDARY_BUS_CONTROL_BASE: IOPortOffset = 0x376;

/// # R/W: Data Register (16-bit / 16-bit)
/// Read/Write PIO data bytes
pub const DATA_REGISTER_OFFSET_FROM_IO_BASE: IOPortOffset = 0;

/// # R: Error Register (8-bit / 16-bit)
/// Used to retrieve any error generated by the last ATA command executed.
pub const ERROR_REGISTER_OFFSET_FROM_IO_BASE: IOPortOffset = 1;

/// # W: Features Register (8-bit / 16-bit)
/// Used to control command specific interface features.
pub const FEATURES_REGISTER_OFFSET_FROM_IO_BASE: IOPortOffset = 1;

/// # R/W: Sector Count Register (8-bit / 16-bit)
/// Number of sectors to read/write (0 is a special value).
pub const SECTOR_COUNT_OFFSET_FROM_IO_BASE: IOPortOffset = 2;

/// # R/W: Sector Number Register (LBAlo) (8-bit / 16-bit)
/// This is CHS / LBA28 / LBA48 specific.
pub const SECTOR_NUM_LOW_OFFSET_FROM_IO_BASE: IOPortOffset = 3;

/// # R/W: Cylinder Low Register / (LBAmid) (8-bit / 16-bit)
/// Partial Disk Sector address.
pub const SECTOR_NUM_MID_OFFSET_FROM_IO_BASE: IOPortOffset = 4;

/// # R/W: Cylinder High Register / (LBAhi)	(8-bit / 16-bit)
/// Partial Disk Sector address.
pub const SECTOR_NUM_HIGH_OFFSET_FROM_IO_BASE: IOPortOffset = 5;

/// # R/W: Drive / Head Register (8-bit / 8-bit)
/// Used to select a drive and/or head. Supports extra address/flag bits.
pub const DRIVE_HEAD_OFFSET_FROM_IO_BASE: IOPortOffset = 6;

/// # R: Status Register (8-bit / 8-bit)
/// Used to read the current status.
pub const STATUS_REGISTER_OFFSET_FROM_IO_BASE: IOPortOffset = 7;

/// # W: Command Register (8-bit / 8-bit)
/// Used to send ATA commands to the device.
pub const COMMAND_OFFSET_FROM_IO_BASE: IOPortOffset = 7;

/// # R: Alternate Status Register (8-bit / 8-bit)
/// A duplicate of the Status Register which does not affect interrupts.
pub const ALTERNATE_STATUS_REGISTER_OFFSET_FROM_CONTROL_BASE: IOPortOffset = 0;

/// # W: Device Control Register (8-bit / 8-bit)
/// Used to reset the bus or enable/disable interrupts.
pub const DEVICE_CONTROL_REGISTER_OFFSET_FROM_CONTROL_BASE: IOPortOffset = 0;

/// # R: Drive Address Register (8-bit / 8-bit)
/// Provides drive select and head select information.
pub const DRIVE_ADDRESS_REGISTER_OFFSET_FROM_CONTROL_BASE: IOPortOffset = 1;

/// # IO Port Offset
/// A strongly typed usize to represent the offset of an IOPort. This is
/// helpful when having to do IOPort address calculation.
pub type IOPortOffset = usize;

/// # Resolve IO Port Bus Offset
/// Returns the IOPort object that this type will use to interface
/// with its hardware.
pub trait ResolveIOPortBusOffset<const BUS_OFFSET: IOPortOffset> {
    fn bus_io(disk_id: DiskID) -> IOPort {
        let new_io = disk_id.bus_base() + BUS_OFFSET;
        IOPort::new(new_io as u16)
    }
}

/// # Resolve IO Port Control Offset
/// Returns the IOPort object that this type will use to interface
/// will its hardware.
pub trait ResolveIOPortControlOffset<const CONTROL_OFFSET: IOPortOffset> {
    fn control_io(disk_id: DiskID) -> IOPort {
        let new_io = disk_id.control_base() + CONTROL_OFFSET;
        IOPort::new(new_io as u16)
    }
}

/// # Disk ID
/// The address if you will of the disk. Determines what PIO addresses to use.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DiskID {
    PrimaryFirst,
    PrimarySecond,
    SecondaryFirst,
    SecondarySecond,
}

impl DiskID {
    /// # Disk ID Iter
    /// An array of objects to serve as a iterator for the enum. Elements
    /// are ordered as apprears in enum.
    pub const DISK_ID_ITER: [DiskID; 4] = [
        Self::PrimaryFirst,
        Self::PrimarySecond,
        Self::SecondaryFirst,
        Self::SecondarySecond,
    ];

    /// # Iter
    /// Returns an iterator over DiskID. Elements are ordered as apprears
    /// in enum.
    pub fn iter() -> Iter<'static, DiskID> {
        Self::DISK_ID_ITER.iter()
    }

    /// # Is Primary?
    /// Checks if the DiskID is on the primary bus.
    pub fn is_primary(&self) -> bool {
        match *self {
            Self::PrimaryFirst => true,
            Self::PrimarySecond => true,
            Self::SecondaryFirst => false,
            Self::SecondarySecond => false,
        }
    }

    /// # Is First?
    /// Checks if DiskID is the first device on the bus.
    pub fn is_first(&self) -> bool {
        match *self {
            Self::PrimaryFirst => true,
            Self::PrimarySecond => false,
            Self::SecondaryFirst => true,
            Self::SecondarySecond => false,
        }
    }

    /// # Is Second?
    /// Checks if DiskID is the second device on the bus.
    pub fn is_second(&self) -> bool {
        !self.is_first()
    }

    /// # Control Base
    /// Gets the `IOPortOffset` of this DiskID
    pub const fn control_base(&self) -> IOPortOffset {
        match *self {
            Self::PrimaryFirst => PRIMARY_BUS_CONTROL_BASE,
            Self::PrimarySecond => PRIMARY_BUS_CONTROL_BASE,
            Self::SecondaryFirst => SECONDARY_BUS_CONTROL_BASE,
            Self::SecondarySecond => SECONDARY_BUS_CONTROL_BASE,
        }
    }

    /// # Bus Base
    /// Gets the `IOPortOffset` of this DiskID
    pub const fn bus_base(&self) -> IOPortOffset {
        match *self {
            Self::PrimaryFirst => PRIMARY_BUS_IO_BASE,
            Self::PrimarySecond => PRIMARY_BUS_IO_BASE,
            Self::SecondaryFirst => SECONDARY_BUS_IO_BASE,
            Self::SecondarySecond => SECONDARY_BUS_IO_BASE,
        }
    }
}
